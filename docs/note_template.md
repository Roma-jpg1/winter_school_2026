# Шаблон заметки (1–2 страницы)

Вам нужно кратко зафиксировать свои решения, чтобы их можно было объяснить и проверить. Текст не должен быть длинным — цель не в “документации ради документации”, а в ясности.

## 1) Что реализовано
- Какие пакеты/компоненты затронуты.
- Какие операции поддерживаются (`Put/Get/Delete/Scan`, flush/compaction и т.п.).

- Put(key, value) — вставка или обновление значения по ключу

- Get(key) — поиск значения по ключу

- Delete(key) — удаление ключа

- Scan(start, end) — ленивый range scan по диапазону [start, end)
## 2) Инварианты и семантика
- Что означает “обновление ключа”.
- Как работает `Scan([start,end))`.
- Как обрабатываются отсутствующие ключи и удаления.
- Обновление ключа:
  если ключ уже существует, его значение перезаписывается без изменения структуры списка.

- Scan([start, end)):
возвращает итератор, который проходит ключи в отсортированном порядке,
включая start и исключая end.
start == nil как -∞, end == nil — как +∞.

- Отсутствующие ключи:
Get и Delete возвращают ErrNotFound, если ключ не найден.

- Итерация реализована лениво: данные не собираются заранее, переход идёт по нулевому уровню skiplist.

## 3) Принятые решения (и почему)
Примеры:
- структура SkipList: почему выбран такой maxLevel? Как реализована генерация уровня?
- SSTable: формат файла (блоки/индекс/footer), как устроен итератор.
- WAL: формат записи, как обеспечивается однозначный парсинг.
- Bloom: какие параметры (m,k) выбраны и почему.
- Streaming: какой алгоритм выбран и какие гарантии/ошибки вы считаете допустимыми.


- maxLevel:
задан фиксированным значением (100), что упрощает реализацию и не влияет на корректность тестов day1.

- Генерация уровня узла:
используется генератор rand.Rand с фиксированным seed, передаваемым в New(seed),
что обеспечивает детерминированное поведение в тестах.

- Копирование key/value:
при Put, Get и Scan данные копируются, чтобы избежать алиасинга и изменения внутреннего состояния извне.

- Сентинел (Head):
используется фиктивный head-узел с массивом next длины maxLevel для упрощения логики поиска и вставки.
## 4) Контроль (как проверялось)
- Какие тесты покрывают ключевые свойства.
- Какие бенчмарки запускались и какой тренд наблюдается при росте N.

## 5) Известные ограничения
- Что намеренно упрощено (однопоточность, отсутствие снапшотов, отсутствие сетевого слоя и т.п.).
